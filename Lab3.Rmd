---
title: "Lab 3: Polygons and Rasters"
---

\
```{r}
library(sf)
library(MapGAM)
library(tidyverse)
library(tidycensus)
library(tigris)
library(flextable)
library(terra)
```

In [Lab 2](lab2.html), we worked with the tidycensus package and the Census API to bring in Census data into R. We can use the same commands to bring in Census geography. If you haven’t already, make sure to [sign up for and install your Census API key](https://api.census.gov/data/key_signup.html). If you could not install your API key, you’ll need to use `census_api_key()` to activate it.

```{r, eval = FALSE}
census_api_key("YOUR API KEY GOES HERE", install = TRUE)
```

```{r, echo=FALSE, eval=FALSE}
census_api_key("5d68935c96c26ee67ca52eb973d71e4a7b8490ad", install = TRUE)
```
\

Use the `set_acs()` command to bring in California tract-level race/ethnicity counts, total population, and total number of households. How did I find the variable IDs? Check [Lab 2](Lab2.html). Since we want tracts, we’ll use the `geography = "tract"` argument.
```{r}
ca.tracts <- get_acs(geography = "tract", 
              year = 2023,
              variables = c(tpopr = "B03002_001", 
                            nhwhite = "B03002_003", nhblk = "B03002_004", 
                            nhasn = "B03002_006", hisp = "B03002_012"), 
              state = "CA",
              output = "wide",
              survey = "acs5",
              geometry = TRUE,
              cb = FALSE)
```

\

The only difference between the code above and what we used in [Lab 2](lab2.html) is we have one additional argument added to the `get_acs()` command: `geometry = TRUE`. This tells R to bring in the spatial features associated with the geography you specified in the command, in the above case California tracts. You can set `cache_table = TRUE` so that you don’t have to re-download after you’ve downloaded successfully the first time. This is important because you might be downloading a really large file, or may encounter Census FTP issues when trying to collect data. 

\

We can also download the data another way. We can go to the [Census Shapefiles website](https://www.census.gov/cgi-bin/geo/shapefiles/index.php) and navigate to 2023, Census Tracts, then California. We will then download a .zip file that contains an ESRI shapefile of the Census tracts for California. When we unzip the file, we see a series of files. Thankfully, the **sf** package has an `st_read()` function that can tackle this! For more detailed data downloads, you can use [National Historical Geographic Information System (NHGIS)](https://www.nhgis.org/).

```{r eval=FALSE}
ca.tracts <- st_read("/Users/pjames1/Downloads/tl_2024_06_tract/tl_2024_06_tract.shp")
```


Lets take a look at our data.

\

```{r}
ca.tracts
```

\

The object looks much like a basic tibble, but with a few differences.

  - You’ll find that the description of the object now indicates that it is a simple feature collection with 9,129 features (tracts in   - California) with 13 fields (attributes or columns of data).
  - The `Geometry Type` indicates that the spatial data are in `MULTIPOLYGON` form (as opposed to points or lines, the other basic vector data forms).
  - `Bounding box` indicates the spatial extent of the features (from left to right, for example, California tracts go from a longitude of -124.482 to -114.1312).
  - `Geodetic CRS` tells us the coordinate reference system.
  - The final difference is that the data frame contains the column geometry. This column (a list-column) contains the geometry for each observation. This looks familiar!
  
At its most basic, an **sf** object is a collection of simple features that includes attributes and geometries in the form of a data frame. In other words, it is a data frame (or tibble) with rows of features, columns of attributes, and a special column always named geometry that contains the spatial aspects of the features.

If you want to peek behind the curtain and learn more about the nitty gritty details about simple features, check out the official **sf** [vignette.](https://r-spatial.github.io/sf/articles/sf1.html)

\

# Data Wrangling

There is a lot of stuff [behind the curtain](https://www.jessesadler.com/post/simple-feature-objects/) of how R handles spatial data as simple features, but the main takeaway is that **sf** objects are data frames. This means you can use many of the **tidyverse** functions we’ve learned in the past couple labs to manipulate **sf** objects, including the pipe `%>%` operator. For example, let’s do the following data wrangling tasks on `ca.tracts`.

1. Keep necessary variables using the `select()` function
2. Break up the column *NAME* into separate tract, county and state variables using the `separate()` function

We do all of this in one line of continuous code using the pipe operator `%>%`

```{r}
ca.tracts <- ca.tracts %>%
              dplyr::select(GEOID, NAME, tpoprE, nhwhiteE, nhblkE, nhasnE, hispE) %>%
              separate(NAME, c("Tract", "County", "State"), sep = "; ")

glimpse(ca.tracts)
```

\

Another important data wrangling operation is to join attribute data to an sf object. For example, let’s say you wanted to add tract level median household income, which is located in the file ca_med_inc_2018.csv. Read the file in.

```{r}
ca.inc <- get_acs(geography = "tract", 
              year = 2023,
              variables = c(medinc = "B19013_001"), 
              state = "CA",
              survey = "acs5",
              output = "wide")
```

\

Unlike before, we brought these data in without the `geometry = TRUE` option. So this is just a table. But remember, an **sf** object is a data frame, so we can use `left_join()`, which we covered in [Lab 1](lab1.html), to join the files *ca.inc* and *ca.tracts*.

```{r}
ca.tracts <- ca.tracts %>%
  left_join(ca.inc, by = "GEOID")

#take a look to make sure the join worked
glimpse(ca.tracts)
```

\

Note that we can’t use `left_join()` to join the attribute tables of two **sf** files. You will need to either make one of them not spatial by using the `st_drop_geometry()` function or use the `st_join()` function to spatially join them.

We use the function `tm_shape()` from the **tmap** package to map the data. 

```{r}
tmap_mode("plot")
tract_map <- tm_shape(ca.tracts) +   tm_polygons()
tract_map
```

\

# Spatial Data Wrangling

There is Data Wrangling and then there is Spatial Data Wrangling. Cue dangerous sounding music. Well, it’s not that dangerous or scary. Spatial Data Wrangling involves cleaning or altering your data set based on the geographic location of features. The **sf** package offers a suite of functions unique to wrangling spatial data. Most of these functions start out with the prefix `st_`. To see all of the functions, type in

```{r}
methods(class = "sf")
```

\

We won’t go through all of these functions as the list is quite extensive. But, we’ll go through a few relevant spatial operations for this class below. The function we will be primarily using is `st_join()`.

## Intersect

A common spatial data wrangling issue is to subset a set of spatial objects based on their location relative to another spatial object. In our case, we want to keep California tracts that are in the Sacramento metro area. We can do this using the `st_join()` function. We’ll need to specify a type of join. Let’s first try `join = st_intersects`.

```{r}

```


# Mapping in R

## ggplot
## tmap
### Choropleth map
### Color scheme
### Legend
### Title
### Scale bar and arrow
### Dot map
### Interactive Maps
## leaflet
## Saving maps



# Rasters

Raster datasets are simply an array of pixels/cells organized into rows and columns (or a grid) where each cell contains a value representing information, such as temperature, soil type, land use, water level. Raster maps usually represent continuous phenomena such as elevation, temperature, population density or spectral data. Discrete features such as soil or land-cover classes can also be represented in the raster data model. Rasters are aerial photographs, imagery from satellites, google street view images. Few things to note.

 - Raster datasets are always rectangular (rows x col) similar to matrices. Irregular boundaries are created by using NAs.
 - Rasters have to contain values of the same type (int, float, boolean) throughout the raster, just like matrices and unlike data frames.
 - The size of the raster depends on the resolution and the extent of the raster. As such many rasters are large and often cannot be held in memory completely.
 - The workhorse package for working with rasters in R is raster and terra packages by Robert Hijmans. terra is better and faster in many instances, but is newer and does not have all the functionality and support associated with raster.

Typically you will bring in a raster dataset directly from a file. These files come in many different forms, typically .tif, .img, and .grd.

We’ll bring in the files sac_county_lc.tif and nlcd_classes.csv. The first file contains USGS land cover (for example, Low Intensity Developed, Deciduous Forest) for Sacramento county based on classes defined by the National Land Cover Dataset. The second file contains the descriptions of the land cover classes.

We use the function raster() to bring in data into raster form.
